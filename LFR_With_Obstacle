#define ena 10
#define inA 8
#define inB 7 
#define inC 11
#define inD 12
#define enb 5
#define trigPin 2
#define echoPin 3

const int irPins[5] = {A0,A1,A2,A3,A4};
const int obstacleDistance = 15; // Distance in cm to detect obstacle

void wheel(int lm, int rm);
int s[5] = {0,0,0,0,0}; 
int i, lastSensor,lastError;
int uturn = 180;
int base_L= 160;
int base_R=160;
float kp=1;
float kd=1;

void setup()
{
  //Serial.begin(9600);
  mot_init();
  other_init();
  sonar_init();
}

void loop()
{ 
  int distance = getDistance();
  
  if(distance > 0 && distance < obstacleDistance)
  {
    // Obstacle detected - avoid it
    avoidObstacle();
  }
  else
  {
    // No obstacle - follow line normally
    line_follow();
  }
}

void sonar_init()
{
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
}

int getDistance()
{
  long duration;
  int distance;
  
  // Clear the trigPin
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  
  // Send 10 microsecond pulse
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  // Read the echoPin
  duration = pulseIn(echoPin, HIGH, 30000); // 30ms timeout
  
  // Calculate distance in cm
  distance = duration * 0.034 / 2;
  
  // Return 0 if no echo received (timeout)
  if(duration == 0) return 0;
  
  return distance;
}

void avoidObstacle()
{
  // Stop first
  wheel(0, 0);
  delay(200);
  
  // Back up a bit
  wheel(0, 0);
  delay(300);
  wheel(0, 0);
  delay(200);
  // Turn right to avoid obstacle
  wheel(110, -110);
  delay(600); // Adjust for 90 degree turn
  wheel(0, 0);
  delay(200);
  // Move forward
  wheel(100, 100);
  delay(1000);
  wheel(0, 0);
  delay(200);
  // Turn left to get back on track
  wheel(-110, 110);
  delay(600);
  wheel(0, 0);
  delay(200);
  // Move forward a bit
  wheel(110, 110);
  delay(500);
  wheel(0, 0);
  delay(200);
  // Turn left again
  wheel(-110, 110);
  delay(600);
  wheel(0, 0);
  delay(200);
  // Continue until line is found
  while(readSensor() == 420)
  {
    wheel(100, 100);
    delay(50);
  }
}

void other_init()
{
  lastSensor=0;
  lastError=0;
  //Serial.begin(9600);
}

void mot_init()
{
  pinMode(inA,OUTPUT);
  pinMode(inB,OUTPUT);
  pinMode(inC,OUTPUT);
  pinMode(inD,OUTPUT);
  pinMode(ena,OUTPUT);
  pinMode(enb,OUTPUT);
}

void wheel(int lm, int rm)
{
  if(lm==0)
  {
    digitalWrite(inC,HIGH);
    digitalWrite(inD,HIGH);
  }
  if(lm>0)
  {
    digitalWrite(inC,HIGH);
    digitalWrite(inD,LOW);
  }
  else if(lm<0)
  {
    digitalWrite(inC,LOW);
    digitalWrite(inD,HIGH);
  }
  if(rm==0)
  {
    digitalWrite(inA,HIGH);
    digitalWrite(inB,HIGH);
  }
  if(rm>0)
  {
    digitalWrite(inA,HIGH);
    digitalWrite(inB,LOW);
  }
  else if(rm<0)
  {
    digitalWrite(inA,LOW);
    digitalWrite(inB,HIGH);
  }
  if(lm>254) lm=254;
  if(lm<-254) lm=-254;
  if(rm>254) rm=254;
  if(rm<-254) rm=-254;
  
  analogWrite(ena,abs(rm));
  analogWrite(enb,abs(lm));
}

int readSensor()
{
  s[0]=digitalRead(irPins[0]);
  s[1]=digitalRead(irPins[1]);
  s[2]=digitalRead(irPins[2]);
  s[3]=digitalRead(irPins[3]);
  s[4]=digitalRead(irPins[4]);
  s[0]=1-s[0];
  s[1]=1-s[1];
  s[2]=1-s[2];
  s[3]=1-s[3];
  s[4]=1-s[4];
  
  int error,sum;
  sum=s[0]+s[1]+s[2]+s[3]+s[4];
  if(sum!=0)
  {
    error=(s[0]*10+s[1]*20+s[2]*30+s[3]*40+s[4]*50)/sum-30;
  }
  else
  {
    error=420;
  }
  
  if(s[0]==1) lastSensor=1;
  else if(s[4]==1) lastSensor=2;
  
  return error;
}

void turnRight()
{
  wheel(100, -100);
  delay(500);
}

void line_follow()
{
  int error, corr;
  float p, d;
  error = readSensor();

  if (error == 420)
  {
    if (lastSensor == 1) wheel(-uturn, uturn);
    else if (lastSensor == 2) wheel(uturn, -uturn);
  }
  else if (s[0] == 1 && s[1] == 1 && s[2] == 1 && s[3] == 1 && s[4] == 1)
  {
    turnRight();
  }
  else 
  { 
    p = kp * error;
    d = kd * (error - lastError);
    corr = p + d;
    
    if (abs(error) < 10)
    {
      wheel(150 + corr, 150 - corr);
    }
    else
    {
      wheel(base_L + corr, base_R - corr);
    }
    
    if ((error - lastError) != 0) delay(5);
    lastError = error; 
  }
}
